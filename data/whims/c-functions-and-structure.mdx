---
title: "C语言-函数与程序结构"
date: "2025-10-16"
---

# T1: 模拟投掷骰子游戏

## 任务描述

本关任务（习题 5.1）：模拟掷双骰子游戏，游戏规则：每轮投两次骰子，取两次的和，第一轮若和为 7 或 11 则获胜，游戏结束。

- 例一：

和为 11，则显示：`'Round 1:  Score:11  Success!'`
若和为 2、3 或 12 则输了，失败结束，

- 例二：

和为 12，则显示：'Round 1: Score:12 Failed!'
若和为其他数字，则将第一轮两次骰子点数的和（假定为 8）作为自己的点数，继续第二轮，第三轮，……，直到某轮两次骰子点数的和等于该点数（第一轮两次投掷点数和）则获胜，若中间某轮两次投掷骰子点数的和为 7，则输掉游戏。对应显示：

```
'Round 1:  Score:8  Continue!'
'Next rounds: Score 8:Success, Score 7:Failed, others:Continue'
'Round 2:  Score:4  Continue!'
'Round 3:  Score:6  Continue!'
'Round 4:  Score:9  Continue!'
'Round 5:  Score:7  Failed!'
```

## 相关知识

为了完成本关任务，你需要掌握：

- C 语言函数定义与调用；

- C 语言函数参数传递与返回；

- C 语言生成指定范围的随机数。

## 编程要求

在右侧编辑器完成 diceGame(int randSeed)函数，其中参数 randSeed 为随机数种子，为方便测试，种子在测试文件中由键盘输入。

## 测试说明

平台会对你编写的代码进行测试，由于 rand()函数返回的随机数在 windows 和 Linux（平台环境）下的值不同，为方便同学们测试，分别给出两种环境的测试结果：

- Linux 环境

测试输入：`1` //随机数种子：用于初始化随机数生成器
预期输出：`Round 1:  Score:7  Success!`

测试输入：`18`
预期输出：

```
'Round 1:  Score:8  Continue!'
'Next rounds: Score 8:Success, Score 7:Failed, others:Continue'
'Round 2:  Score:4  Continue!'
'Round 3:  Score:6  Continue!'
'Round 4:  Score:9  Continue!'
'Round 5:  Score:7  Failed!'
```

- windows 环境

测试输入：`100` //随机数种子：用于初始化随机数生成器
预期输出：Round 1: Score:11 Success!

测试输入：`10`

预期输出：

```
'Round 1:  Score:10  Continue!'
'Next rounds: Score 10:Success, Score 7:Failed, others:Continue'
'Round 2:  Score:6  Continue!'
'Round 3:  Score:9  Continue!'
'Round 4:  Score:4  Continue!'
'Round 5:  Score:7  Failed!'
```

开始你的任务吧，祝你成功！

## 抽象解答

```c
/*
getScore() 函数用于获取每一轮投掷骰子之后的和

@return a+b 两个骰子之和
*/
int getScore()
{
    int a = rand() % 6 + 1;
    int b = rand() % 6 + 1;

    return a + b;
}

void diceGame(int randSeed)
{
    int a, b;
    srand(randSeed); // 初始化随机数生成

    int round = 1, score = getScore();

    if (score == 2 || score == 3 || score == 12)
    {
        printf("Round 1:  Score:%d  Failed!\n", score);
    }
    else
    {
        if (score == 7 || score == 11)
        {
            printf("Round 1:  Score:%d  Success!\n", score);
        }
        else
        {
            printf("Round 1:  Score:%d  Continue!\n", score);
            printf("Next rounds: Score %d:Success, Score 7:Failed, others:Continue\n", score);
            round = 2;
            int goal = score;
            while (1)
            {
                score = getScore();

                if (score != 7)
                {
                    if (goal == score)
                    {
                        printf("Round %d:  Score:%d  Success!\n", round, score);
                        break;
                    }
                    else
                    {
                        printf("Round %d:  Score:%d  Continue!\n", round, score);
                        round++;
                    }
                }
                else
                {
                    printf("Round %d:  Score:7  Failed!\n", round);
                    break;
                }
            }
            /* 循环调用getScore()获取骰子点数之和，当遇到成功或者失败条件跳出循环 */
        }
    }
}
```

**注**:此题后面的神奇判定逻辑并不难写，写到能跑就行似乎就行了，考虑函数设置是关键

# T2：冰雹数

## 任务描述

本关任务（习题 5.11）：

$n_{0}$是一个给定的正整数，对于$i=0，1，2...$，定义：

1. 若$n_{i}$是偶数，则$n_{i+1}=n_{i}/2$；

2. 若$n_{i}$是奇数，则$n_{i+1}=3n_{i} +1$；

3. 若$n_{i}$是 1，则序列结束。

用该方法产生的数称为冰雹(hailstone)。

编写产生一些冰雹的程序，程序应该用函数`void hailstone(int n)`；计算冰雹并显示由 n 产生的序列。程序的输出见:测试说明

## 相关知识

为了完成本关任务，你需要掌握：

- 冰雹程序的设计；

- 函数的创建与调用。

## 编程要求

在右侧编辑器的`Begin-End`之间补充`hailstone()`函数，此函数输入为一个整数，没有返回值，输出给定整数的冰雹数。

## 测试说明

平台会对你编写的代码进行测试，若是与预期输出相同，则算通关。输出为给定整数的冰雹数，输出格式已在函数中给出。

测试输入：`77    //输入为给定的整数`

预期输出：（每个冰雹数占 5 位宽，一行输出 6 个数）

```
input a number:Hailstone generated by 77:
  77  232  116   58   29   88
  44   22   11   34   17   52
  26   13   40   20   10    5
  16    8    4    2    1
Number of hailstone generated:23
```

## 抽象解答

```C
#include <stdio.h>

void hailstone(int n)
{
    int count = 1;
    printf("Hailstone generated by %d:\n", n);

    printf("%5d", n); // 首先输出本身，例如示例中的`77`

    while (1)
    {
        if (n % 2 == 0)
        {
            n /= 2;
            printf("%5d", n);
            count++;
        }
        else
        {
            if (n == 1)
            {
                break; //直接跳出循环，不必增加`count`，因为得到1的时候已经打印过1了
            }
            n = 3 * n + 1;
            printf("%5d", n);
            count++;
        }

        if (count % 6 == 0)
        {
            printf("\n"); //每行输出6个
        }
    }

    printf("\nNumber of hailstone generated:%d", count);
}

```

**注**:此题逻辑并不复杂，重点是输出格式的控制

# T3：输出整数中指定位数的值

## 任务描述

本关任务（习题 5.13）：输入整数`n`和`k`，输出`n`中从右端开始的第`k`个数字的值（`k`从 1 开始）。

将求 n 中右端第 k 个数字定义成函数`digit(n,k)`，如果`k`超过了`n`的位数，则函数返回-1；否则返回`n`中第`k`个数字。

例如：`digit(345876,4)=5，digit(345,4)=-1。`

## 相关知识

为了完成本关任务，你需要掌握：

C 语言整数除法与取余操作；

C 语言函数的创建与调用。

## 编程要求

在右侧编辑器中的`Begin-End`之间补充`digit()`函数，此函数输入为`n`与`k`，返回`n`从右开始的第`k`个数字，如果`k`超过了`n`的位数，则返回`-1`。

测试说明
平台会对你编写的代码进行测试，比对你输出的数值与实际正确数值，只有所有数据全部计算正确才能通过测试：

测试输入：`345876 4  //输入的是n = 345876 , k = 4`

预期输出：`5`

## 抽象解答

```c
#include <stdio.h>
#include <math.h>

int digit(long n, int k)
{
    if (n == 0 && k == 1)
    {
        return 0;
    }
    //以上判断极其关键，如果缺失定会有一个不过测hh

    if (n < (int)pow(10, k - 1) || k > 10)
    {
        return -1;
    }
    else
    {
        int result = (n % (int)pow(10, k)) / (int)pow(10, k - 1);
        return result;
    }
}
```

**注**:此题这么做过测没有问题，但是存在很大的安全隐患：由于`double`的精度问题，很难保证输出结果一定正确，尤其是`k`很大的时候，如果要改进可以考虑用循环代替`pow()`函数的功能

# T4：递归实现标准库函数`strlen()`

## 任务描述

本关任务（习题 12.2）：用递归实现标准库函数 `strlen(s)`。

## 相关知识

为了完成本关任务，你需要掌握：

- C 语言中递归的设计与实现；

- 库函数 `strlen(s)`的功能。

## 编程要求

在右侧编辑器中的 `Begin-End` 之间中补充 `mystrlen()函数`，函数输入为字符串地址，函数返回字符串的长度。

## 测试说明

平台会对你编写的代码进行测试，比对你输出的数值与实际正确数值，只有所有数据全部计算正确才能通过测试：

测试输入：`husterNB!`

预期输出：`9`

## 抽象解答

```c
#include<stdlib.h>
#include<stdio.h>
#include<string.h>

int length = 0;
int mystrlen(char *s)
{

    if (*s) //*s指向一个字符，当*s指向\0的时候，条件不满足，终止递归
    {
        length++;
        mystrlen(s + 1); //从第一个字符向右逐个移动递归确认
    }

    return length;
}
```

**注**:无话可说

# T5：递归实现逆序

## 任务描述

本关任务（习题 12.3）：将输入的一行字符逆序输出。

例如，输入 `string`，则输出 `gnirts`。将逆序输出用递归函数实现。

## 相关知识

为了完成本关任务，你需要掌握 C 语言递归函数的设计与实现。

## 编程要求

在右侧编辑器中的 `Begin-End` 之间补充 `myrever()`函数，此函数使用递归的方法完成输入一行字符，逆序输出该行字符，该函数没有参数，没有返回值。输入和输出字符用 `getchar` 和 `putchar` 函数。

## 测试说明

平台会对你编写的代码进行测试，比对你输出的数值与实际正确数值，只有所有数据全部计算正确才能通过测试：

测试输入：`string`

预期输出：`gnirts`

## 抽象解答

```C
#include <stdio.h>

/**
  请使用递归定义此函数，将输入的一行字符逆序输出。
  字符的输入和输出用getchar和putchar函数
 **/
void myrever(void)
{
    char str[114],c; //开一个足够大的存储字符串的数组，`c`用于暂存字符
    int length = 0;

    while ((c = getchar()) != '\n' && c != EOF)
    // 首先将输入的字符赋值给`c`，不遇到换行符或者终止符一直执行循环，并一个一个字符存储在`str`数组中
    // 细节`length++`，先读取`length`的旧值，然后让其自增存储下一个字符
    {
        str[length++] = c;
    }

    for (int i = 0; i < length; i++)
    {
        if (i < length - i - 1)
        {
            char t = str[i];
            str[i] = str[length - i - 1];
            str[length - i - 1] = t;
            //使用中间变量`t`实现交换
        }
    }

    for (int i = 0; i < length; i++)
    {
        putchar(str[i]);
    }
}
```

# T6：最大公约数

## 任务描述

本关任务：用辗转相除法计算两个数的最大公约数，要求用递归函数实现求最大公约数。

## 相关知识

为了完成本关任务，你需要掌握：1. 辗转相除算法，2. 如何定义递归函数。

## 编程要求

在右侧编辑器中的`Begin-End`之间补充`gcd（x,y）`函数代码，计算并返回`x`和`y`的最大公约数,在递归求解中输出辗转相除的过程。最终的公约数返回到测试文件输出。

## 测试说明

平台会对你编写的代码进行测试：

测试输入：`24  16`

预期输出：

```
24 16
16 8
8 0
8
```

## 抽象解答

```c
int seen = 0; //全局定义`seen`其实有风险，因为下次执行的时候会有问题，不过过测没问题

int gcd(int x, int y)
{
    if (seen == 0) //在没有`seen`的情况下，直接输出求最大公约数的两个数
    {
        printf("%d %d\n", x, y);
    }
    seen = 1;
    if (x < y)
    {
        int t = x;
        x = y;
        y = t;
    }
    // 如果 x 比 y 小，交换两个数的值以便打印输出详细信息

    int c = x % y;

    if (c != 0)
    {
        x = y;
        y = c;
        printf("%d %d\n", x, y);
        gcd(x, y); // 辗转相除法，没什么好说的，这里继续递归
    }
    else
    {
        printf("%d %d\n", y, c);
        return y; // 当余数为0时，返回y
    }

    if (x == 0 || y == 0)
    {
        return 0;
    }
    // 处理特例：有一方为 0 的时候，最大公约数为 0
}
```

**注**:此题最难的部分反而不是递归的过程，而是运算过程每一步的打印，包括开始正式辗转相除法之前的输出原始值其实很让人头疼
