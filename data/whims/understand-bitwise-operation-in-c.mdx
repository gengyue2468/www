---
title: "浅入浅出地理解 C 语言中的二进制位运算"
date: "2025-10-24"
---

最近在学习 C 语言，在做头歌的理论课实训作业的时候遇到了不少有关 C 语言中位运算的问题，深知理解很不到位，因此写这么一篇随想，旨在浅入浅出地理解二进制位运算。

# 几个基本运算符

## & 运算符

& 运算符中文描述为“与”运算，当二者都是 1 的时候，结果才是 1 ，类似集合概念中的交集运算, 例如:

```c
0b00011100 & 0b00001011 == 0b00001000
```

## | 运算符

类似上面的与运算，或运算与之相反，二者中只要有一个是 1，结果就是 1，类似集合概念中的并集概念，例如：

```c
0b00011100 | 0b00001011 == 0b00011111
```

## ^ 运算符

^ 运算符被描述为“异或运算”，当二者不同的时候才是 1， 相同则为 0，例如：

```c
1^1 = 0
1^0 = 1
0^1 = 1
0^0 = 0
```

显然，我们可以找到它的一个常见的用途，就是找一个掩码，翻转另一个数的指定几位，例如：

```c
mask = 0b0000 1111
num = 0b1011 1101

new_num = num^mask // 0b1011 0010
```

## ~ 运算符

~ 运算符是“取反”运算，例如：

```c
~1 = 1111 1110
~0 = 1111 1111
```

作用：结合 & 运算可以让某个数的某几位变成 0，例如：

```c
a = 0b0100 1111;
a &= ~ 0x03 //即0b0000 0011 取反后变成 0b1111 1100
// a = 0b0100 1100
```

## \<< 与 \>> 运算符

顾名思义，\<< 和 \>> 运算符是指将某个二进制向左/向右移动某个位数，多余溢出的部分补 0。

那么你可能会思考，如何实现循环移动呢？就是指在移动的过程中，移除的部分自动补到前端/后端，也就是不补 0。

下面是一个简单的例子，介绍了如何实现循环移动：

```C
int n;

scanf("%d", &n);

unsigned a = 0x0FC3;
unsigned b = (a << n) | (a >> (16 - n));
```

# 整型对应的二进制位数

相信聪明的你一定不会和我一样对于各种类型的二进制位数感到迷惑吧，但是为了防止我迷惑，我决定 CV 一份表格放在下边：

| 数据类型           | 标准最小位数 | 32 位系统常见位数 | 64 位系统常见位数 |
| ------------------ | ------------ | ----------------- | ----------------- |
| char               | 8 位         | 8 位              | 8 位              |
| signed char        | 8 位         | 8 位              | 8 位              |
| unsigned char      | 8 位         | 8 位              | 8 位              |
| short / short int  | 16 位        | 16 位             | 16 位             |
| unsigned short     | 16 位        | 16 位             | 16 位             |
| int                | 16 位        | 32 位             | 32 位             |
| unsigned int       | 16 位        | 32 位             | 32 位             |
| long / long int    | 32 位        | 32 位             | 64 位             |
| unsigned long      | 32 位        | 32 位             | 64 位             |
| long long          | 64 位        | 64 位             | 64 位             |
| unsigned long long | 64 位        | 64 位             | 64 位             |

# 几个例题

很好，相信聪明的你已经全面掌握了有关位运算的内容了，下面我们来看几个例题：

## T1 读取 IP 地址

**题目要求** 读入无符号长整型数表示的互联网 IP 地址，对其译码，以常见的点分十进制形式输出。

**测试输入**：

```
3232235876
1
^Z
```

**预期输出**：

```
192.168.1.100
```

要做这个题目，我们考虑对 IP 译码的时候，按照 8 位二进制依次转换为十进制的方法进行

```C
#include <stdio.h>

void format_ip(unsigned long ori)
{
    int fst = (ori >> 24) & 0xFF; //向右移动24位，提取高8位
    int sec = (ori >> 16) & 0xFF; //向右移动16位，提取左高8位
    int thi = (ori >> 8) & 0xFF; //向右移动8位，提取右低8位
    int four = ori & 0xFF;      //向右移动0位，提取低8位

    printf("%d.%d.%d.%d\n", fst, sec, thi, four);
}

int main()
{
    unsigned long ori_ip;

    while (1)
    {
        scanf("%lu", &ori_ip);
        format_ip(ori_ip);
        if (getchar() == EOF)
        {
            break;
        }
    }

    //死循环，当键盘输出终止符的时候跳出循环

    return 0;
}
```

## T2 取出一个整数的连续若干位

**题目要求** 取出 x 从第ｍ位开始向左的ｎ位。

**测试输入**：

```
4 2 1
```

**预期输出** (以十六进制输出)

```
8000
```

考虑如下的掩码：

```
0xFFFF
```

这是一个全部位都是 1 的二进制数，我们使用这个掩码来进行下面的操作：

首先，我们需要将`mask`想左移动`16-n`位，然后右移回去，这样，我们就创建了一个有 n 位是`1`，其余位是`0`的掩码

```c
mask = (mask << (16-n)) >> (16-n);
```

下一步，让我们把掩码移动到正确的位置：

```C
mask = mask << m; // 注意是 unsigned int 类型
```

下面，我们把 x 按位移动到最低位

```C
x >> m;
```

然后，我们按位或进行运算，提取目标 n 位

```c
x &= mask;
```

进而，向左移动到最高位

```c
x = x << (16 - n);
```

最后打印输出结果`printf("%X", x);`即可

完整的代码如下：

```c
#include <stdio.h>

int main()
{
    unsigned x = 0, m = 0, n = 0;
    unsigned result = 0;
    unsigned mask = 0xFFFF;

    scanf("%u %u %u", &x, &m, &n);

    mask = (mask << (16 - n)) >> (16 - n);

    x = x >> m;

    result = (mask & x) << (16 - n);

    printf("%X", result);

    return 0;
}
```

先写到这吧 EOF
